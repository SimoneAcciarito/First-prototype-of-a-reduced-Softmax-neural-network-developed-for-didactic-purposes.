// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\r24b_pseudosoftmax_in10_8bit\stage4_add.v
// Created: 2025-09-29 11:51:53
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: stage4_add
// Source Path: r24b_pseudosoftmax_in10_8bit/PseudoSM_ASIC/FLP_adder/stage4_add
// Hierarchy Level: 2
// Model version: 9.0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module stage4_add
          (clk,
           reset,
           exp1,
           exp2,
           mant1,
           mant2,
           exp_out,
           mant_out);


  input   clk;
  input   reset;
  input   signed [10:0] exp1;  // sfix11
  input   signed [10:0] exp2;  // sfix11
  input   [7:0] mant1;  // ufix8_En8
  input   [7:0] mant2;  // ufix8_En8
  output  signed [11:0] exp_out;  // sfix12
  output  [7:0] mant_out;  // ufix8_En8


  wire Relational_Operator_out1;
  reg  Delay10_out1;
  reg  [2:0] Delay11_reg;  // ufix1 [3]
  wire Delay11_out1;
  reg signed [10:0] Delay12_reg [0:3];  // sfix11 [4]
  reg signed [10:0] Delay12_reg_next [0:3];  // sfix11 [4]
  reg signed [10:0] Delay12_out1;  // sfix11
  reg signed [10:0] Delay13_reg [0:3];  // sfix11 [4]
  reg signed [10:0] Delay13_reg_next [0:3];  // sfix11 [4]
  reg signed [10:0] Delay13_out1;  // sfix11
  wire signed [10:0] Multiport_Switch_out1;  // sfix11
  reg  [1:0] Delay7_reg;  // ufix1 [2]
  wire Delay7_out1;
  wire Constant4_out1;
  wire [8:0] Bit_Concat1_out1;  // ufix9
  wire [8:0] Data_Type_Conversion2_out1;  // ufix9_En8
  reg [8:0] Delay8_reg [0:2];  // ufix9 [3]
  reg [8:0] Delay8_reg_next [0:2];  // ufix9_En8 [3]
  reg [8:0] Delay8_out1;  // ufix9_En8
  wire [8:0] Bit_Concat_out1;  // ufix9
  wire [8:0] Data_Type_Conversion1_out1;  // ufix9_En8
  reg [8:0] Delay9_reg [0:2];  // ufix9 [3]
  reg [8:0] Delay9_reg_next [0:2];  // ufix9_En8 [3]
  reg [8:0] Delay9_out1;  // ufix9_En8
  wire [8:0] Multiport_Switch3_out1;  // ufix9_En8
  reg  Delay4_out1;
  reg [8:0] Delay5_reg [0:1];  // ufix9 [2]
  wire [8:0] Delay5_reg_next [0:1];  // ufix9_En8 [2]
  wire [8:0] Delay5_out1;  // ufix9_En8
  reg [8:0] Delay6_reg [0:1];  // ufix9 [2]
  wire [8:0] Delay6_reg_next [0:1];  // ufix9_En8 [2]
  wire [8:0] Delay6_out1;  // ufix9_En8
  wire [8:0] Multiport_Switch2_out1;  // ufix9_En8
  wire signed [11:0] Add1_1;  // sfix12
  wire signed [11:0] Add1_2;  // sfix12
  wire signed [11:0] Add1_out1;  // sfix12
  reg signed [11:0] Delay_out1;  // sfix12
  wire signed [12:0] Abs_y;  // sfix13
  wire signed [12:0] Abs_1;  // sfix13
  wire [3:0] Abs_out1;  // ufix4
  reg [3:0] Delay1_out1;  // ufix4
  wire [7:0] shift_arithmetic_cast;  // uint8
  wire [8:0] Shift_Arithmetic_out1;  // ufix9_En8
  reg [8:0] Delay2_out1;  // ufix9_En8
  wire [9:0] Add2_add_cast;  // ufix10_En8
  wire [9:0] Add2_add_cast_1;  // ufix10_En8
  wire [9:0] Add2_out1;  // ufix10_En8
  reg [9:0] Delay3_out1;  // ufix10_En8
  wire Extract_Bits_out1;  // ufix1
  wire signed [11:0] Add_1;  // sfix12
  wire signed [11:0] Add_2;  // sfix12
  wire signed [11:0] Add_out1;  // sfix12
  wire [8:0] Extract_Bits1_out1;  // ufix9
  wire [8:0] Bit_Shift_out1;  // ufix9
  wire [8:0] Multiport_Switch4_out1;  // ufix9
  wire [7:0] Extract_Bits2_out1;  // uint8
  wire [7:0] Data_Type_Conversion_out1;  // ufix8_En8
  reg signed [31:0] Delay12_t_0_0;  // int32
  reg signed [31:0] Delay12_t_0_1;  // int32
  reg signed [31:0] Delay12_t_1;  // int32
  reg signed [31:0] Delay13_t_0_0;  // int32
  reg signed [31:0] Delay13_t_0_1;  // int32
  reg signed [31:0] Delay13_t_1;  // int32
  reg signed [31:0] Delay8_t_0_0;  // int32
  reg signed [31:0] Delay8_t_0_1;  // int32
  reg signed [31:0] Delay8_t_1;  // int32
  reg signed [31:0] Delay9_t_0_0;  // int32
  reg signed [31:0] Delay9_t_0_1;  // int32
  reg signed [31:0] Delay9_t_1;  // int32
  reg signed [31:0] Delay5_t_0_0;  // int32
  reg signed [31:0] Delay5_t_1;  // int32
  reg signed [31:0] Delay6_t_0_0;  // int32
  reg signed [31:0] Delay6_t_1;  // int32


  assign Relational_Operator_out1 = exp1 >= exp2;

  always @(posedge clk or posedge reset)
    begin : Delay10_process
      if (reset == 1'b1) begin
        Delay10_out1 <= 1'b0;
      end
      else begin
        Delay10_out1 <= Relational_Operator_out1;
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay11_process
      if (reset == 1'b1) begin
        Delay11_reg <= {3{1'b0}};
      end
      else begin
        Delay11_reg[0] <= Delay10_out1;
        Delay11_reg[32'sd2:32'sd1] <= Delay11_reg[32'sd1:32'sd0];
      end
    end

  assign Delay11_out1 = Delay11_reg[2];

  always @(posedge clk or posedge reset)
    begin : Delay12_process
      if (reset == 1'b1) begin
        for(Delay12_t_1 = 32'sd0; Delay12_t_1 <= 32'sd3; Delay12_t_1 = Delay12_t_1 + 32'sd1) begin
          Delay12_reg[Delay12_t_1] <= 11'sb00000000000;
        end
      end
      else begin
        for(Delay12_t_0_1 = 32'sd0; Delay12_t_0_1 <= 32'sd3; Delay12_t_0_1 = Delay12_t_0_1 + 32'sd1) begin
          Delay12_reg[Delay12_t_0_1] <= Delay12_reg_next[Delay12_t_0_1];
        end
      end
    end

  always @* begin
    Delay12_out1 = Delay12_reg[3];
    Delay12_reg_next[0] = exp2;

    for(Delay12_t_0_0 = 32'sd0; Delay12_t_0_0 <= 32'sd2; Delay12_t_0_0 = Delay12_t_0_0 + 32'sd1) begin
      Delay12_reg_next[Delay12_t_0_0 + 32'sd1] = Delay12_reg[Delay12_t_0_0];
    end

  end

  always @(posedge clk or posedge reset)
    begin : Delay13_process
      if (reset == 1'b1) begin
        for(Delay13_t_1 = 32'sd0; Delay13_t_1 <= 32'sd3; Delay13_t_1 = Delay13_t_1 + 32'sd1) begin
          Delay13_reg[Delay13_t_1] <= 11'sb00000000000;
        end
      end
      else begin
        for(Delay13_t_0_1 = 32'sd0; Delay13_t_0_1 <= 32'sd3; Delay13_t_0_1 = Delay13_t_0_1 + 32'sd1) begin
          Delay13_reg[Delay13_t_0_1] <= Delay13_reg_next[Delay13_t_0_1];
        end
      end
    end

  always @* begin
    Delay13_out1 = Delay13_reg[3];
    Delay13_reg_next[0] = exp1;

    for(Delay13_t_0_0 = 32'sd0; Delay13_t_0_0 <= 32'sd2; Delay13_t_0_0 = Delay13_t_0_0 + 32'sd1) begin
      Delay13_reg_next[Delay13_t_0_0 + 32'sd1] = Delay13_reg[Delay13_t_0_0];
    end

  end

  assign Multiport_Switch_out1 = (Delay11_out1 == 1'b0 ? Delay12_out1 :
              Delay13_out1);

  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        Delay7_reg <= {2{1'b0}};
      end
      else begin
        Delay7_reg[0] <= Delay10_out1;
        Delay7_reg[1] <= Delay7_reg[0];
      end
    end

  assign Delay7_out1 = Delay7_reg[1];

  assign Constant4_out1 = 1'b1;

  assign Bit_Concat1_out1 = {Constant4_out1, mant2};

  assign Data_Type_Conversion2_out1 = Bit_Concat1_out1;

  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        for(Delay8_t_1 = 32'sd0; Delay8_t_1 <= 32'sd2; Delay8_t_1 = Delay8_t_1 + 32'sd1) begin
          Delay8_reg[Delay8_t_1] <= 9'b000000000;
        end
      end
      else begin
        for(Delay8_t_0_1 = 32'sd0; Delay8_t_0_1 <= 32'sd2; Delay8_t_0_1 = Delay8_t_0_1 + 32'sd1) begin
          Delay8_reg[Delay8_t_0_1] <= Delay8_reg_next[Delay8_t_0_1];
        end
      end
    end

  always @* begin
    Delay8_out1 = Delay8_reg[2];
    Delay8_reg_next[0] = Data_Type_Conversion2_out1;

    for(Delay8_t_0_0 = 32'sd0; Delay8_t_0_0 <= 32'sd1; Delay8_t_0_0 = Delay8_t_0_0 + 32'sd1) begin
      Delay8_reg_next[Delay8_t_0_0 + 32'sd1] = Delay8_reg[Delay8_t_0_0];
    end

  end

  assign Bit_Concat_out1 = {Constant4_out1, mant1};

  assign Data_Type_Conversion1_out1 = Bit_Concat_out1;

  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        for(Delay9_t_1 = 32'sd0; Delay9_t_1 <= 32'sd2; Delay9_t_1 = Delay9_t_1 + 32'sd1) begin
          Delay9_reg[Delay9_t_1] <= 9'b000000000;
        end
      end
      else begin
        for(Delay9_t_0_1 = 32'sd0; Delay9_t_0_1 <= 32'sd2; Delay9_t_0_1 = Delay9_t_0_1 + 32'sd1) begin
          Delay9_reg[Delay9_t_0_1] <= Delay9_reg_next[Delay9_t_0_1];
        end
      end
    end

  always @* begin
    Delay9_out1 = Delay9_reg[2];
    Delay9_reg_next[0] = Data_Type_Conversion1_out1;

    for(Delay9_t_0_0 = 32'sd0; Delay9_t_0_0 <= 32'sd1; Delay9_t_0_0 = Delay9_t_0_0 + 32'sd1) begin
      Delay9_reg_next[Delay9_t_0_0 + 32'sd1] = Delay9_reg[Delay9_t_0_0];
    end

  end

  assign Multiport_Switch3_out1 = (Delay7_out1 == 1'b0 ? Delay8_out1 :
              Delay9_out1);

  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 1'b0;
      end
      else begin
        Delay4_out1 <= Delay10_out1;
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        for(Delay5_t_1 = 32'sd0; Delay5_t_1 <= 32'sd1; Delay5_t_1 = Delay5_t_1 + 32'sd1) begin
          Delay5_reg[Delay5_t_1] <= 9'b000000000;
        end
      end
      else begin
        for(Delay5_t_0_0 = 32'sd0; Delay5_t_0_0 <= 32'sd1; Delay5_t_0_0 = Delay5_t_0_0 + 32'sd1) begin
          Delay5_reg[Delay5_t_0_0] <= Delay5_reg_next[Delay5_t_0_0];
        end
      end
    end

  assign Delay5_out1 = Delay5_reg[1];
  assign Delay5_reg_next[0] = Data_Type_Conversion1_out1;
  assign Delay5_reg_next[1] = Delay5_reg[0];

  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        for(Delay6_t_1 = 32'sd0; Delay6_t_1 <= 32'sd1; Delay6_t_1 = Delay6_t_1 + 32'sd1) begin
          Delay6_reg[Delay6_t_1] <= 9'b000000000;
        end
      end
      else begin
        for(Delay6_t_0_0 = 32'sd0; Delay6_t_0_0 <= 32'sd1; Delay6_t_0_0 = Delay6_t_0_0 + 32'sd1) begin
          Delay6_reg[Delay6_t_0_0] <= Delay6_reg_next[Delay6_t_0_0];
        end
      end
    end

  assign Delay6_out1 = Delay6_reg[1];
  assign Delay6_reg_next[0] = Data_Type_Conversion2_out1;
  assign Delay6_reg_next[1] = Delay6_reg[0];

  assign Multiport_Switch2_out1 = (Delay4_out1 == 1'b0 ? Delay5_out1 :
              Delay6_out1);

  assign Add1_1 = {exp1[10], exp1};
  assign Add1_2 = {exp2[10], exp2};
  assign Add1_out1 = Add1_1 - Add1_2;

  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_out1 <= 12'sb000000000000;
      end
      else begin
        Delay_out1 <= Add1_out1;
      end
    end

  assign Abs_1 = {Delay_out1[11], Delay_out1};
  assign Abs_y = (Delay_out1 < 12'sb000000000000 ?  - (Abs_1) :
              {Delay_out1[11], Delay_out1});
  assign Abs_out1 = ((Abs_y[12] == 1'b0) && (Abs_y[11:4] != 8'b00000000) ? 4'b1111 :
              (Abs_y[12] == 1'b1 ? 4'b0000 :
              Abs_y[3:0]));

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 4'b0000;
      end
      else begin
        Delay1_out1 <= Abs_out1;
      end
    end

  assign shift_arithmetic_cast = {4'b0, Delay1_out1};
  assign Shift_Arithmetic_out1 = Multiport_Switch2_out1 >>> shift_arithmetic_cast;

  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 9'b000000000;
      end
      else begin
        Delay2_out1 <= Shift_Arithmetic_out1;
      end
    end

  assign Add2_add_cast = {1'b0, Multiport_Switch3_out1};
  assign Add2_add_cast_1 = {1'b0, Delay2_out1};
  assign Add2_out1 = Add2_add_cast + Add2_add_cast_1;

  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 10'b0000000000;
      end
      else begin
        Delay3_out1 <= Add2_out1;
      end
    end

  assign Extract_Bits_out1 = Delay3_out1[9];

  assign Add_1 = {Multiport_Switch_out1[10], Multiport_Switch_out1};
  assign Add_2 = {11'b0, Extract_Bits_out1};
  assign Add_out1 = Add_1 + Add_2;

  assign exp_out = Add_out1;

  assign Extract_Bits1_out1 = Delay3_out1[8:0];

  assign Bit_Shift_out1 = Extract_Bits1_out1 >> 8'd1;

  assign Multiport_Switch4_out1 = (Extract_Bits_out1 == 1'b0 ? Extract_Bits1_out1 :
              Bit_Shift_out1);

  assign Extract_Bits2_out1 = Multiport_Switch4_out1[7:0];

  assign Data_Type_Conversion_out1 = Extract_Bits2_out1;

  assign mant_out = Data_Type_Conversion_out1;

endmodule  // stage4_add

