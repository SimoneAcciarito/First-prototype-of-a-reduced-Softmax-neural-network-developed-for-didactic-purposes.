// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\r24b_pseudosoftmax_in10_8bit\PseudoSM_ASIC.v
// Created: 2025-09-29 11:51:53
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Model base rate: 1
// Target subsystem base rate: 1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: PseudoSM_ASIC
// Source Path: r24b_pseudosoftmax_in10_8bit/PseudoSM_ASIC
// Hierarchy Level: 0
// Model version: 9.0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module PseudoSM_ASIC
          (clk,
           reset,
           Sel_out,
           Data_in,
           Sel_in,
           Data_out);


  input   clk;
  input   reset;
  input   [3:0] Sel_out;  // ufix4
  input   signed [7:0] Data_in;  // int8
  input   [3:0] Sel_in;  // ufix4
  output  [7:0] Data_out;  // uint8


  reg [3:0] Delay2_out1;  // ufix4
  reg signed [7:0] Delay6_out1;  // int8
  reg [3:0] Delay7_out1;  // ufix4
  wire signed [7:0] Input_DEMUX_out1;  // int8
  wire signed [7:0] Input_DEMUX_out2;  // int8
  wire signed [7:0] Input_DEMUX_out3;  // int8
  wire signed [7:0] Input_DEMUX_out4;  // int8
  wire signed [7:0] Input_DEMUX_out5;  // int8
  wire signed [7:0] Input_DEMUX_out6;  // int8
  wire signed [7:0] Input_DEMUX_out7;  // int8
  wire signed [7:0] Input_DEMUX_out8;  // int8
  wire signed [7:0] Input_DEMUX_out9;  // int8
  wire signed [7:0] Input_DEMUX_out10;  // int8
  wire signed [11:0] FLP_adder_out1;  // sfix12
  wire [7:0] FLP_adder_out2;  // ufix8_En8
  reg signed [11:0] Delay3_out1;  // sfix12
  wire signed [7:0] Mux_out1 [0:9];  // int8 [10]
  reg signed [7:0] Delay5_reg [0:159];  // sfix8 [160]
  reg signed [7:0] Delay5_reg_next [0:159];  // sfix8 [160]
  reg signed [7:0] Delay5_out1 [0:9];  // int8 [10]
  wire signed [12:0] Final_sub_out1_0;  // sfix13
  wire signed [12:0] Final_sub_out1_1;  // sfix13
  wire signed [12:0] Final_sub_out1_2;  // sfix13
  wire signed [12:0] Final_sub_out1_3;  // sfix13
  wire signed [12:0] Final_sub_out1_4;  // sfix13
  wire signed [12:0] Final_sub_out1_5;  // sfix13
  wire signed [12:0] Final_sub_out1_6;  // sfix13
  wire signed [12:0] Final_sub_out1_7;  // sfix13
  wire signed [12:0] Final_sub_out1_8;  // sfix13
  wire signed [12:0] Final_sub_out1_9;  // sfix13
  wire signed [12:0] Final_sub_out1 [0:9];  // sfix13 [10]
  wire [7:0] Bit_Slice_out1 [0:9];  // uint8 [10]
  reg [7:0] Delay9_out1 [0:9];  // uint8 [10]
  wire [7:0] Delay9_out1_0;  // uint8
  wire [7:0] Delay9_out1_1;  // uint8
  wire [7:0] Delay9_out1_2;  // uint8
  wire [7:0] Delay9_out1_3;  // uint8
  wire [7:0] Delay9_out1_4;  // uint8
  wire [7:0] Delay9_out1_5;  // uint8
  wire [7:0] Delay9_out1_6;  // uint8
  wire [7:0] Delay9_out1_7;  // uint8
  wire [7:0] Delay9_out1_8;  // uint8
  reg [7:0] Delay4_out1;  // ufix8_En8
  wire [7:0] Reciprocal_PWL_out1;  // ufix8_En7
  wire [7:0] Delay9_out1_9;  // uint8
  reg [7:0] Delay1_out1;  // ufix8_En7
  wire [7:0] Data_Type_Conversion2_out1;  // uint8
  wire [7:0] Multiport_Switch_out1;  // uint8
  reg [7:0] Delay8_out1;  // uint8
  reg signed [31:0] Delay5_t_0_0;  // int32
  reg signed [31:0] Delay5_t_1;  // int32
  reg signed [31:0] Delay5_t_0_1;  // int32
  reg signed [31:0] Delay5_t_1_0;  // int32
  reg signed [31:0] Delay9_t_0_0;  // int32
  reg signed [31:0] Delay9_t_1;  // int32


  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 4'b0000;
      end
      else begin
        Delay2_out1 <= Sel_out;
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 8'sb00000000;
      end
      else begin
        Delay6_out1 <= Data_in;
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        Delay7_out1 <= 4'b0000;
      end
      else begin
        Delay7_out1 <= Sel_in;
      end
    end

  Input_DEMUX u_Input_DEMUX (.clk(clk),
                             .reset(reset),
                             .Data(Delay6_out1),  // int8
                             .Sel(Delay7_out1),  // ufix4
                             .exp1(Input_DEMUX_out1),  // int8
                             .exp2(Input_DEMUX_out2),  // int8
                             .exp3(Input_DEMUX_out3),  // int8
                             .exp4(Input_DEMUX_out4),  // int8
                             .exp5(Input_DEMUX_out5),  // int8
                             .exp6(Input_DEMUX_out6),  // int8
                             .exp7(Input_DEMUX_out7),  // int8
                             .exp8(Input_DEMUX_out8),  // int8
                             .exp9(Input_DEMUX_out9),  // int8
                             .exp10(Input_DEMUX_out10)  // int8
                             );

  FLP_adder u_FLP_adder (.clk(clk),
                         .reset(reset),
                         .exp1(Input_DEMUX_out1),  // int8
                         .exp2(Input_DEMUX_out2),  // int8
                         .exp3(Input_DEMUX_out3),  // int8
                         .exp4(Input_DEMUX_out4),  // int8
                         .exp5(Input_DEMUX_out5),  // int8
                         .exp6(Input_DEMUX_out6),  // int8
                         .exp7(Input_DEMUX_out7),  // int8
                         .exp8(Input_DEMUX_out8),  // int8
                         .exp9(Input_DEMUX_out9),  // int8
                         .exp10(Input_DEMUX_out10),  // int8
                         .exp_out(FLP_adder_out1),  // sfix12
                         .mant_out(FLP_adder_out2)  // ufix8_En8
                         );

  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 12'sb000000000000;
      end
      else begin
        Delay3_out1 <= FLP_adder_out1;
      end
    end

  assign Mux_out1[0] = Input_DEMUX_out1;
  assign Mux_out1[1] = Input_DEMUX_out2;
  assign Mux_out1[2] = Input_DEMUX_out3;
  assign Mux_out1[3] = Input_DEMUX_out4;
  assign Mux_out1[4] = Input_DEMUX_out5;
  assign Mux_out1[5] = Input_DEMUX_out6;
  assign Mux_out1[6] = Input_DEMUX_out7;
  assign Mux_out1[7] = Input_DEMUX_out8;
  assign Mux_out1[8] = Input_DEMUX_out9;
  assign Mux_out1[9] = Input_DEMUX_out10;

  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        for(Delay5_t_1_0 = 32'sd0; Delay5_t_1_0 <= 32'sd159; Delay5_t_1_0 = Delay5_t_1_0 + 32'sd1) begin
          Delay5_reg[Delay5_t_1_0] = 8'sb00000000;
        end
      end
      else begin
        for(Delay5_t_0_1 = 32'sd0; Delay5_t_0_1 <= 32'sd159; Delay5_t_0_1 = Delay5_t_0_1 + 32'sd1) begin
          Delay5_reg[Delay5_t_0_1] = Delay5_reg_next[Delay5_t_0_1];
        end
      end
    end

  always @* begin

    for(Delay5_t_0_0 = 32'sd0; Delay5_t_0_0 <= 32'sd9; Delay5_t_0_0 = Delay5_t_0_0 + 32'sd1) begin
      Delay5_out1[Delay5_t_0_0] = Delay5_reg[32'sd150 + Delay5_t_0_0];
      Delay5_reg_next[Delay5_t_0_0] = Mux_out1[Delay5_t_0_0];
    end
    for(Delay5_t_1 = 32'sd0; Delay5_t_1 <= 32'sd149; Delay5_t_1 = Delay5_t_1 + 32'sd1) begin
      Delay5_reg_next[Delay5_t_1 + 32'sd10] = Delay5_reg[Delay5_t_1];
    end

  end

  Final_sub u_Final_sub (.Minus(Delay3_out1),  // sfix12
                         .Plus_0(Delay5_out1[0]),  // int8
                         .Plus_1(Delay5_out1[1]),  // int8
                         .Plus_2(Delay5_out1[2]),  // int8
                         .Plus_3(Delay5_out1[3]),  // int8
                         .Plus_4(Delay5_out1[4]),  // int8
                         .Plus_5(Delay5_out1[5]),  // int8
                         .Plus_6(Delay5_out1[6]),  // int8
                         .Plus_7(Delay5_out1[7]),  // int8
                         .Plus_8(Delay5_out1[8]),  // int8
                         .Plus_9(Delay5_out1[9]),  // int8
                         .Sub_0(Final_sub_out1_0),  // sfix13
                         .Sub_1(Final_sub_out1_1),  // sfix13
                         .Sub_2(Final_sub_out1_2),  // sfix13
                         .Sub_3(Final_sub_out1_3),  // sfix13
                         .Sub_4(Final_sub_out1_4),  // sfix13
                         .Sub_5(Final_sub_out1_5),  // sfix13
                         .Sub_6(Final_sub_out1_6),  // sfix13
                         .Sub_7(Final_sub_out1_7),  // sfix13
                         .Sub_8(Final_sub_out1_8),  // sfix13
                         .Sub_9(Final_sub_out1_9)  // sfix13
                         );

  assign Final_sub_out1[0] = Final_sub_out1_0;
  assign Final_sub_out1[1] = Final_sub_out1_1;
  assign Final_sub_out1[2] = Final_sub_out1_2;
  assign Final_sub_out1[3] = Final_sub_out1_3;
  assign Final_sub_out1[4] = Final_sub_out1_4;
  assign Final_sub_out1[5] = Final_sub_out1_5;
  assign Final_sub_out1[6] = Final_sub_out1_6;
  assign Final_sub_out1[7] = Final_sub_out1_7;
  assign Final_sub_out1[8] = Final_sub_out1_8;
  assign Final_sub_out1[9] = Final_sub_out1_9;


  genvar k1;
  generate
    for(k1 = 32'sd0; k1 <= 32'sd9; k1 = k1 + 32'sd1) begin:Bit_Slice_out1_gen
      assign Bit_Slice_out1[k1] = Final_sub_out1[k1][7:0];
    end
  endgenerate

  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        for(Delay9_t_1 = 32'sd0; Delay9_t_1 <= 32'sd9; Delay9_t_1 = Delay9_t_1 + 32'sd1) begin
          Delay9_out1[Delay9_t_1] <= 8'b00000000;
        end
      end
      else begin
        for(Delay9_t_0_0 = 32'sd0; Delay9_t_0_0 <= 32'sd9; Delay9_t_0_0 = Delay9_t_0_0 + 32'sd1) begin
          Delay9_out1[Delay9_t_0_0] <= Bit_Slice_out1[Delay9_t_0_0];
        end
      end
    end

  assign Delay9_out1_0 = Delay9_out1[0];

  assign Delay9_out1_1 = Delay9_out1[1];

  assign Delay9_out1_2 = Delay9_out1[2];

  assign Delay9_out1_3 = Delay9_out1[3];

  assign Delay9_out1_4 = Delay9_out1[4];

  assign Delay9_out1_5 = Delay9_out1[5];

  assign Delay9_out1_6 = Delay9_out1[6];

  assign Delay9_out1_7 = Delay9_out1[7];

  assign Delay9_out1_8 = Delay9_out1[8];

  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 8'b00000000;
      end
      else begin
        Delay4_out1 <= FLP_adder_out2;
      end
    end

  Reciprocal_PWL u_Reciprocal_PWL (.mant_out(Delay4_out1),  // ufix8_En8
                                   .mant_out1(Reciprocal_PWL_out1)  // ufix8_En7
                                   );

  assign Delay9_out1_9 = Delay9_out1[9];

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 8'b00000000;
      end
      else begin
        Delay1_out1 <= Reciprocal_PWL_out1;
      end
    end

  assign Data_Type_Conversion2_out1 = Delay1_out1;

  assign Multiport_Switch_out1 = (Delay2_out1 == 4'b0000 ? Delay9_out1_0 :
              (Delay2_out1 == 4'b0001 ? Delay9_out1_1 :
              (Delay2_out1 == 4'b0010 ? Delay9_out1_2 :
              (Delay2_out1 == 4'b0011 ? Delay9_out1_3 :
              (Delay2_out1 == 4'b0100 ? Delay9_out1_4 :
              (Delay2_out1 == 4'b0101 ? Delay9_out1_5 :
              (Delay2_out1 == 4'b0110 ? Delay9_out1_6 :
              (Delay2_out1 == 4'b0111 ? Delay9_out1_7 :
              (Delay2_out1 == 4'b1000 ? Delay9_out1_8 :
              (Delay2_out1 == 4'b1001 ? Delay9_out1_9 :
              Data_Type_Conversion2_out1))))))))));

  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        Delay8_out1 <= 8'b00000000;
      end
      else begin
        Delay8_out1 <= Multiport_Switch_out1;
      end
    end

  assign Data_out = Delay8_out1;

endmodule  // PseudoSM_ASIC

