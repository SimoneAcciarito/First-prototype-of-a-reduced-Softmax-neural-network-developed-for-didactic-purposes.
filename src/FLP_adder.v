// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\r24b_pseudosoftmax_in10_8bit\FLP_adder.v
// Created: 2025-09-29 11:51:53
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: FLP_adder
// Source Path: r24b_pseudosoftmax_in10_8bit/PseudoSM_ASIC/FLP_adder
// Hierarchy Level: 1
// Model version: 9.0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module FLP_adder
          (clk,
           reset,
           exp1,
           exp2,
           exp3,
           exp4,
           exp5,
           exp6,
           exp7,
           exp8,
           exp9,
           exp10,
           exp_out,
           mant_out);


  input   clk;
  input   reset;
  input   signed [7:0] exp1;  // int8
  input   signed [7:0] exp2;  // int8
  input   signed [7:0] exp3;  // int8
  input   signed [7:0] exp4;  // int8
  input   signed [7:0] exp5;  // int8
  input   signed [7:0] exp6;  // int8
  input   signed [7:0] exp7;  // int8
  input   signed [7:0] exp8;  // int8
  input   signed [7:0] exp9;  // int8
  input   signed [7:0] exp10;  // int8
  output  signed [11:0] exp_out;  // sfix12
  output  [7:0] mant_out;  // ufix8_En8


  wire signed [8:0] stage1_add_out1;  // sfix9
  wire [7:0] stage1_add_out2;  // ufix8_En8
  reg signed [8:0] Delay_out1;  // sfix9
  wire signed [8:0] stage1_add1_out1;  // sfix9
  wire [7:0] stage1_add1_out2;  // ufix8_En8
  reg signed [8:0] Delay2_out1;  // sfix9
  reg [7:0] Delay1_out1;  // ufix8_En8
  reg [7:0] Delay3_out1;  // ufix8_En8
  wire signed [9:0] stage2_add_out1;  // sfix10
  wire [7:0] stage2_add_out2;  // ufix8_En8
  reg signed [9:0] Delay10_out1;  // sfix10
  wire signed [8:0] stage1_add2_out1;  // sfix9
  wire [7:0] stage1_add2_out2;  // ufix8_En8
  reg signed [8:0] Delay4_out1;  // sfix9
  wire signed [8:0] stage1_add3_out1;  // sfix9
  wire [7:0] stage1_add3_out2;  // ufix8_En8
  reg signed [8:0] Delay6_out1;  // sfix9
  reg [7:0] Delay5_out1;  // ufix8_En8
  reg [7:0] Delay7_out1;  // ufix8_En8
  wire signed [9:0] stage2_add1_out1;  // sfix10
  wire [7:0] stage2_add1_out2;  // ufix8_En8
  reg signed [9:0] Delay12_out1;  // sfix10
  reg [7:0] Delay11_out1;  // ufix8_En8
  reg [7:0] Delay13_out1;  // ufix8_En8
  wire signed [10:0] stage3_add_out1;  // sfix11
  wire [7:0] stage3_add_out2;  // ufix8_En8
  wire signed [8:0] stage1_add4_out1;  // sfix9
  wire [7:0] stage1_add4_out2;  // ufix8_En8
  reg signed [10:0] Delay14_out1;  // sfix11
  reg signed [8:0] Delay8_reg [0:10];  // sfix9 [11]
  reg signed [8:0] Delay8_reg_next [0:10];  // sfix9 [11]
  reg signed [8:0] Delay8_out1;  // sfix9
  wire signed [10:0] Data_Type_Conversion_out1;  // sfix11
  reg [7:0] Delay15_out1;  // ufix8_En8
  reg [7:0] Delay9_reg [0:10];  // ufix8 [11]
  reg [7:0] Delay9_reg_next [0:10];  // ufix8_En8 [11]
  reg [7:0] Delay9_out1;  // ufix8_En8
  wire signed [11:0] stage4_add_out1;  // sfix12
  wire [7:0] stage4_add_out2;  // ufix8_En8
  reg signed [31:0] Delay8_t_0_0;  // int32
  reg signed [31:0] Delay8_t_0_1;  // int32
  reg signed [31:0] Delay8_t_1;  // int32
  reg signed [31:0] Delay9_t_0_0;  // int32
  reg signed [31:0] Delay9_t_0_1;  // int32
  reg signed [31:0] Delay9_t_1;  // int32


  stage1_add u_stage1_add (.clk(clk),
                           .reset(reset),
                           .exp1(exp1),  // int8
                           .exp2(exp2),  // int8
                           .exp_out(stage1_add_out1),  // sfix9
                           .mant_out(stage1_add_out2)  // ufix8_En8
                           );

  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_out1 <= 9'sb000000000;
      end
      else begin
        Delay_out1 <= stage1_add_out1;
      end
    end

  stage1_add1 u_stage1_add1 (.clk(clk),
                             .reset(reset),
                             .exp1(exp3),  // int8
                             .exp2(exp4),  // int8
                             .exp_out(stage1_add1_out1),  // sfix9
                             .mant_out(stage1_add1_out2)  // ufix8_En8
                             );

  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 9'sb000000000;
      end
      else begin
        Delay2_out1 <= stage1_add1_out1;
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 8'b00000000;
      end
      else begin
        Delay1_out1 <= stage1_add_out2;
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 8'b00000000;
      end
      else begin
        Delay3_out1 <= stage1_add1_out2;
      end
    end

  stage2_add u_stage2_add (.clk(clk),
                           .reset(reset),
                           .exp1(Delay_out1),  // sfix9
                           .exp2(Delay2_out1),  // sfix9
                           .mant1(Delay1_out1),  // ufix8_En8
                           .mant2(Delay3_out1),  // ufix8_En8
                           .exp_out(stage2_add_out1),  // sfix10
                           .mant_out(stage2_add_out2)  // ufix8_En8
                           );

  always @(posedge clk or posedge reset)
    begin : Delay10_process
      if (reset == 1'b1) begin
        Delay10_out1 <= 10'sb0000000000;
      end
      else begin
        Delay10_out1 <= stage2_add_out1;
      end
    end

  stage1_add2 u_stage1_add2 (.clk(clk),
                             .reset(reset),
                             .exp1(exp5),  // int8
                             .exp2(exp6),  // int8
                             .exp_out(stage1_add2_out1),  // sfix9
                             .mant_out(stage1_add2_out2)  // ufix8_En8
                             );

  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 9'sb000000000;
      end
      else begin
        Delay4_out1 <= stage1_add2_out1;
      end
    end

  stage1_add3 u_stage1_add3 (.clk(clk),
                             .reset(reset),
                             .exp1(exp7),  // int8
                             .exp2(exp8),  // int8
                             .exp_out(stage1_add3_out1),  // sfix9
                             .mant_out(stage1_add3_out2)  // ufix8_En8
                             );

  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_out1 <= 9'sb000000000;
      end
      else begin
        Delay6_out1 <= stage1_add3_out1;
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_out1 <= 8'b00000000;
      end
      else begin
        Delay5_out1 <= stage1_add2_out2;
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        Delay7_out1 <= 8'b00000000;
      end
      else begin
        Delay7_out1 <= stage1_add3_out2;
      end
    end

  stage2_add1 u_stage2_add1 (.clk(clk),
                             .reset(reset),
                             .exp1(Delay4_out1),  // sfix9
                             .exp2(Delay6_out1),  // sfix9
                             .mant1(Delay5_out1),  // ufix8_En8
                             .mant2(Delay7_out1),  // ufix8_En8
                             .exp_out(stage2_add1_out1),  // sfix10
                             .mant_out(stage2_add1_out2)  // ufix8_En8
                             );

  always @(posedge clk or posedge reset)
    begin : Delay12_process
      if (reset == 1'b1) begin
        Delay12_out1 <= 10'sb0000000000;
      end
      else begin
        Delay12_out1 <= stage2_add1_out1;
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay11_process
      if (reset == 1'b1) begin
        Delay11_out1 <= 8'b00000000;
      end
      else begin
        Delay11_out1 <= stage2_add_out2;
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay13_process
      if (reset == 1'b1) begin
        Delay13_out1 <= 8'b00000000;
      end
      else begin
        Delay13_out1 <= stage2_add1_out2;
      end
    end

  stage3_add u_stage3_add (.clk(clk),
                           .reset(reset),
                           .exp1(Delay10_out1),  // sfix10
                           .exp2(Delay12_out1),  // sfix10
                           .mant1(Delay11_out1),  // ufix8_En8
                           .mant2(Delay13_out1),  // ufix8_En8
                           .exp_out(stage3_add_out1),  // sfix11
                           .mant_out(stage3_add_out2)  // ufix8_En8
                           );

  stage1_add4 u_stage1_add4 (.clk(clk),
                             .reset(reset),
                             .exp1(exp9),  // int8
                             .exp2(exp10),  // int8
                             .exp_out(stage1_add4_out1),  // sfix9
                             .mant_out(stage1_add4_out2)  // ufix8_En8
                             );

  always @(posedge clk or posedge reset)
    begin : Delay14_process
      if (reset == 1'b1) begin
        Delay14_out1 <= 11'sb00000000000;
      end
      else begin
        Delay14_out1 <= stage3_add_out1;
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        for(Delay8_t_1 = 32'sd0; Delay8_t_1 <= 32'sd10; Delay8_t_1 = Delay8_t_1 + 32'sd1) begin
          Delay8_reg[Delay8_t_1] <= 9'sb000000000;
        end
      end
      else begin
        for(Delay8_t_0_1 = 32'sd0; Delay8_t_0_1 <= 32'sd10; Delay8_t_0_1 = Delay8_t_0_1 + 32'sd1) begin
          Delay8_reg[Delay8_t_0_1] <= Delay8_reg_next[Delay8_t_0_1];
        end
      end
    end

  always @* begin
    Delay8_out1 = Delay8_reg[10];
    Delay8_reg_next[0] = stage1_add4_out1;

    for(Delay8_t_0_0 = 32'sd0; Delay8_t_0_0 <= 32'sd9; Delay8_t_0_0 = Delay8_t_0_0 + 32'sd1) begin
      Delay8_reg_next[Delay8_t_0_0 + 32'sd1] = Delay8_reg[Delay8_t_0_0];
    end

  end

  assign Data_Type_Conversion_out1 = {{2{Delay8_out1[8]}}, Delay8_out1};

  always @(posedge clk or posedge reset)
    begin : Delay15_process
      if (reset == 1'b1) begin
        Delay15_out1 <= 8'b00000000;
      end
      else begin
        Delay15_out1 <= stage3_add_out2;
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        for(Delay9_t_1 = 32'sd0; Delay9_t_1 <= 32'sd10; Delay9_t_1 = Delay9_t_1 + 32'sd1) begin
          Delay9_reg[Delay9_t_1] <= 8'b00000000;
        end
      end
      else begin
        for(Delay9_t_0_1 = 32'sd0; Delay9_t_0_1 <= 32'sd10; Delay9_t_0_1 = Delay9_t_0_1 + 32'sd1) begin
          Delay9_reg[Delay9_t_0_1] <= Delay9_reg_next[Delay9_t_0_1];
        end
      end
    end

  always @* begin
    Delay9_out1 = Delay9_reg[10];
    Delay9_reg_next[0] = stage1_add4_out2;

    for(Delay9_t_0_0 = 32'sd0; Delay9_t_0_0 <= 32'sd9; Delay9_t_0_0 = Delay9_t_0_0 + 32'sd1) begin
      Delay9_reg_next[Delay9_t_0_0 + 32'sd1] = Delay9_reg[Delay9_t_0_0];
    end

  end

  stage4_add u_stage4_add (.clk(clk),
                           .reset(reset),
                           .exp1(Delay14_out1),  // sfix11
                           .exp2(Data_Type_Conversion_out1),  // sfix11
                           .mant1(Delay15_out1),  // ufix8_En8
                           .mant2(Delay9_out1),  // ufix8_En8
                           .exp_out(stage4_add_out1),  // sfix12
                           .mant_out(stage4_add_out2)  // ufix8_En8
                           );

  assign exp_out = stage4_add_out1;

  assign mant_out = stage4_add_out2;

endmodule  // FLP_adder

