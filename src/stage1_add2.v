// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\r24b_pseudosoftmax_in10_8bit\stage1_add2.v
// Created: 2025-09-29 11:51:53
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: stage1_add2
// Source Path: r24b_pseudosoftmax_in10_8bit/PseudoSM_ASIC/FLP_adder/stage1_add2
// Hierarchy Level: 2
// Model version: 9.0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module stage1_add2
          (clk,
           reset,
           exp1,
           exp2,
           exp_out,
           mant_out);


  input   clk;
  input   reset;
  input   signed [7:0] exp1;  // int8
  input   signed [7:0] exp2;  // int8
  output  signed [8:0] exp_out;  // sfix9
  output  [7:0] mant_out;  // ufix8_En8


  wire Relational_Operator_out1;
  reg  [3:0] Delay4_reg;  // ufix1 [4]
  wire Delay4_out1;
  reg signed [7:0] Delay5_reg [0:3];  // sfix8 [4]
  reg signed [7:0] Delay5_reg_next [0:3];  // sfix8 [4]
  reg signed [7:0] Delay5_out1;  // int8
  reg signed [7:0] Delay6_reg [0:3];  // sfix8 [4]
  reg signed [7:0] Delay6_reg_next [0:3];  // sfix8 [4]
  reg signed [7:0] Delay6_out1;  // int8
  wire signed [7:0] Multiport_Switch_out1;  // int8
  wire [8:0] Constant2_out1;  // ufix9_En8
  wire signed [8:0] Add1_1;  // sfix9
  wire signed [8:0] Add1_2;  // sfix9
  wire signed [8:0] Add1_out1;  // sfix9
  reg signed [8:0] Delay_out1;  // sfix9
  wire signed [9:0] Abs_y;  // sfix10
  wire signed [9:0] Abs_1;  // sfix10
  wire [3:0] Abs_out1;  // ufix4
  reg [3:0] Delay1_out1;  // ufix4
  wire [7:0] shift_arithmetic_cast;  // uint8
  wire [8:0] Shift_Arithmetic_out1;  // ufix9_En8
  reg [8:0] Delay2_out1;  // ufix9_En8
  wire [9:0] Add2_add_cast;  // ufix10_En8
  wire [9:0] Add2_add_cast_1;  // ufix10_En8
  wire [9:0] Add2_out1;  // ufix10_En8
  reg [9:0] Delay3_out1;  // ufix10_En8
  wire Extract_Bits_out1;  // ufix1
  wire signed [8:0] Add_1;  // sfix9
  wire signed [8:0] Add_2;  // sfix9
  wire signed [8:0] Add_out1;  // sfix9
  wire [7:0] Extract_Bits1_out1;  // uint8
  wire [7:0] Data_Type_Conversion_out1;  // ufix8_En8
  reg signed [31:0] Delay5_t_0_0;  // int32
  reg signed [31:0] Delay5_t_0_1;  // int32
  reg signed [31:0] Delay5_t_1;  // int32
  reg signed [31:0] Delay6_t_0_0;  // int32
  reg signed [31:0] Delay6_t_0_1;  // int32
  reg signed [31:0] Delay6_t_1;  // int32


  assign Relational_Operator_out1 = exp1 >= exp2;

  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_reg <= {4{1'b0}};
      end
      else begin
        Delay4_reg[0] <= Relational_Operator_out1;
        Delay4_reg[32'sd3:32'sd1] <= Delay4_reg[32'sd2:32'sd0];
      end
    end

  assign Delay4_out1 = Delay4_reg[3];

  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        for(Delay5_t_1 = 32'sd0; Delay5_t_1 <= 32'sd3; Delay5_t_1 = Delay5_t_1 + 32'sd1) begin
          Delay5_reg[Delay5_t_1] <= 8'sb00000000;
        end
      end
      else begin
        for(Delay5_t_0_1 = 32'sd0; Delay5_t_0_1 <= 32'sd3; Delay5_t_0_1 = Delay5_t_0_1 + 32'sd1) begin
          Delay5_reg[Delay5_t_0_1] <= Delay5_reg_next[Delay5_t_0_1];
        end
      end
    end

  always @* begin
    Delay5_out1 = Delay5_reg[3];
    Delay5_reg_next[0] = exp2;

    for(Delay5_t_0_0 = 32'sd0; Delay5_t_0_0 <= 32'sd2; Delay5_t_0_0 = Delay5_t_0_0 + 32'sd1) begin
      Delay5_reg_next[Delay5_t_0_0 + 32'sd1] = Delay5_reg[Delay5_t_0_0];
    end

  end

  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        for(Delay6_t_1 = 32'sd0; Delay6_t_1 <= 32'sd3; Delay6_t_1 = Delay6_t_1 + 32'sd1) begin
          Delay6_reg[Delay6_t_1] <= 8'sb00000000;
        end
      end
      else begin
        for(Delay6_t_0_1 = 32'sd0; Delay6_t_0_1 <= 32'sd3; Delay6_t_0_1 = Delay6_t_0_1 + 32'sd1) begin
          Delay6_reg[Delay6_t_0_1] <= Delay6_reg_next[Delay6_t_0_1];
        end
      end
    end

  always @* begin
    Delay6_out1 = Delay6_reg[3];
    Delay6_reg_next[0] = exp1;

    for(Delay6_t_0_0 = 32'sd0; Delay6_t_0_0 <= 32'sd2; Delay6_t_0_0 = Delay6_t_0_0 + 32'sd1) begin
      Delay6_reg_next[Delay6_t_0_0 + 32'sd1] = Delay6_reg[Delay6_t_0_0];
    end

  end

  assign Multiport_Switch_out1 = (Delay4_out1 == 1'b0 ? Delay5_out1 :
              Delay6_out1);

  assign Constant2_out1 = 9'b100000000;

  assign Add1_1 = {exp1[7], exp1};
  assign Add1_2 = {exp2[7], exp2};
  assign Add1_out1 = Add1_1 - Add1_2;

  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_out1 <= 9'sb000000000;
      end
      else begin
        Delay_out1 <= Add1_out1;
      end
    end

  assign Abs_1 = {Delay_out1[8], Delay_out1};
  assign Abs_y = (Delay_out1 < 9'sb000000000 ?  - (Abs_1) :
              {Delay_out1[8], Delay_out1});
  assign Abs_out1 = ((Abs_y[9] == 1'b0) && (Abs_y[8:4] != 5'b00000) ? 4'b1111 :
              (Abs_y[9] == 1'b1 ? 4'b0000 :
              Abs_y[3:0]));

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 4'b0000;
      end
      else begin
        Delay1_out1 <= Abs_out1;
      end
    end

  assign shift_arithmetic_cast = {4'b0, Delay1_out1};
  assign Shift_Arithmetic_out1 = Constant2_out1 >>> shift_arithmetic_cast;

  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 9'b000000000;
      end
      else begin
        Delay2_out1 <= Shift_Arithmetic_out1;
      end
    end

  assign Add2_add_cast = {1'b0, Constant2_out1};
  assign Add2_add_cast_1 = {1'b0, Delay2_out1};
  assign Add2_out1 = Add2_add_cast + Add2_add_cast_1;

  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 10'b0000000000;
      end
      else begin
        Delay3_out1 <= Add2_out1;
      end
    end

  assign Extract_Bits_out1 = Delay3_out1[9];

  assign Add_1 = {Multiport_Switch_out1[7], Multiport_Switch_out1};
  assign Add_2 = {8'b0, Extract_Bits_out1};
  assign Add_out1 = Add_1 + Add_2;

  assign exp_out = Add_out1;

  assign Extract_Bits1_out1 = Delay3_out1[7:0];

  assign Data_Type_Conversion_out1 = Extract_Bits1_out1;

  assign mant_out = Data_Type_Conversion_out1;

endmodule  // stage1_add2

