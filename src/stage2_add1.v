// -------------------------------------------------------------
// 
// File Name: hdl_prj\hdlsrc\r24b_pseudosoftmax_in10_8bit\stage2_add1.v
// Created: 2025-09-29 11:51:53
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: stage2_add1
// Source Path: r24b_pseudosoftmax_in10_8bit/PseudoSM_ASIC/FLP_adder/stage2_add1
// Hierarchy Level: 2
// Model version: 9.0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module stage2_add1
          (clk,
           reset,
           exp1,
           exp2,
           mant1,
           mant2,
           exp_out,
           mant_out);


  input   clk;
  input   reset;
  input   signed [8:0] exp1;  // sfix9
  input   signed [8:0] exp2;  // sfix9
  input   [7:0] mant1;  // ufix8_En8
  input   [7:0] mant2;  // ufix8_En8
  output  signed [9:0] exp_out;  // sfix10
  output  [7:0] mant_out;  // ufix8_En8


  wire Relational_Operator_out1;
  reg  Delay4_out1;
  reg  [2:0] Delay5_reg;  // ufix1 [3]
  wire Delay5_out1;
  reg signed [8:0] Delay6_reg [0:3];  // sfix9 [4]
  reg signed [8:0] Delay6_reg_next [0:3];  // sfix9 [4]
  reg signed [8:0] Delay6_out1;  // sfix9
  reg signed [8:0] Delay7_reg [0:3];  // sfix9 [4]
  reg signed [8:0] Delay7_reg_next [0:3];  // sfix9 [4]
  reg signed [8:0] Delay7_out1;  // sfix9
  wire signed [8:0] Multiport_Switch_out1;  // sfix9
  reg  [1:0] Delay13_reg;  // ufix1 [2]
  wire Delay13_out1;
  wire Constant4_out1;
  wire [8:0] Bit_Concat1_out1;  // ufix9
  wire [8:0] Data_Type_Conversion2_out1;  // ufix9_En8
  reg [8:0] Delay12_reg [0:2];  // ufix9 [3]
  reg [8:0] Delay12_reg_next [0:2];  // ufix9_En8 [3]
  reg [8:0] Delay12_out1;  // ufix9_En8
  wire [8:0] Bit_Concat_out1;  // ufix9
  wire [8:0] Data_Type_Conversion1_out1;  // ufix9_En8
  reg [8:0] Delay11_reg [0:2];  // ufix9 [3]
  reg [8:0] Delay11_reg_next [0:2];  // ufix9_En8 [3]
  reg [8:0] Delay11_out1;  // ufix9_En8
  wire [8:0] Multiport_Switch3_out1;  // ufix9_En8
  reg  Delay8_out1;
  reg [8:0] Delay9_reg [0:1];  // ufix9 [2]
  wire [8:0] Delay9_reg_next [0:1];  // ufix9_En8 [2]
  wire [8:0] Delay9_out1;  // ufix9_En8
  reg [8:0] Delay10_reg [0:1];  // ufix9 [2]
  wire [8:0] Delay10_reg_next [0:1];  // ufix9_En8 [2]
  wire [8:0] Delay10_out1;  // ufix9_En8
  wire [8:0] Multiport_Switch2_out1;  // ufix9_En8
  wire signed [9:0] Add1_1;  // sfix10
  wire signed [9:0] Add1_2;  // sfix10
  wire signed [9:0] Add1_out1;  // sfix10
  reg signed [9:0] Delay_out1;  // sfix10
  wire signed [10:0] Abs_y;  // sfix11
  wire signed [10:0] Abs_1;  // sfix11
  wire [3:0] Abs_out1;  // ufix4
  reg [3:0] Delay1_out1;  // ufix4
  wire [7:0] shift_arithmetic_cast;  // uint8
  wire [8:0] Shift_Arithmetic_out1;  // ufix9_En8
  reg [8:0] Delay2_out1;  // ufix9_En8
  wire [9:0] Add2_add_cast;  // ufix10_En8
  wire [9:0] Add2_add_cast_1;  // ufix10_En8
  wire [9:0] Add2_out1;  // ufix10_En8
  reg [9:0] Delay3_out1;  // ufix10_En8
  wire Extract_Bits_out1;  // ufix1
  wire signed [9:0] Add_1;  // sfix10
  wire signed [9:0] Add_2;  // sfix10
  wire signed [9:0] Add_out1;  // sfix10
  wire [8:0] Extract_Bits1_out1;  // ufix9
  wire [8:0] Bit_Shift_out1;  // ufix9
  wire [8:0] Multiport_Switch4_out1;  // ufix9
  wire [7:0] Extract_Bits2_out1;  // uint8
  wire [7:0] Data_Type_Conversion_out1;  // ufix8_En8
  reg signed [31:0] Delay6_t_0_0;  // int32
  reg signed [31:0] Delay6_t_0_1;  // int32
  reg signed [31:0] Delay6_t_1;  // int32
  reg signed [31:0] Delay7_t_0_0;  // int32
  reg signed [31:0] Delay7_t_0_1;  // int32
  reg signed [31:0] Delay7_t_1;  // int32
  reg signed [31:0] Delay12_t_0_0;  // int32
  reg signed [31:0] Delay12_t_0_1;  // int32
  reg signed [31:0] Delay12_t_1;  // int32
  reg signed [31:0] Delay11_t_0_0;  // int32
  reg signed [31:0] Delay11_t_0_1;  // int32
  reg signed [31:0] Delay11_t_1;  // int32
  reg signed [31:0] Delay9_t_0_0;  // int32
  reg signed [31:0] Delay9_t_1;  // int32
  reg signed [31:0] Delay10_t_0_0;  // int32
  reg signed [31:0] Delay10_t_1;  // int32


  assign Relational_Operator_out1 = exp1 >= exp2;

  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 1'b0;
      end
      else begin
        Delay4_out1 <= Relational_Operator_out1;
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_reg <= {3{1'b0}};
      end
      else begin
        Delay5_reg[0] <= Delay4_out1;
        Delay5_reg[32'sd2:32'sd1] <= Delay5_reg[32'sd1:32'sd0];
      end
    end

  assign Delay5_out1 = Delay5_reg[2];

  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        for(Delay6_t_1 = 32'sd0; Delay6_t_1 <= 32'sd3; Delay6_t_1 = Delay6_t_1 + 32'sd1) begin
          Delay6_reg[Delay6_t_1] <= 9'sb000000000;
        end
      end
      else begin
        for(Delay6_t_0_1 = 32'sd0; Delay6_t_0_1 <= 32'sd3; Delay6_t_0_1 = Delay6_t_0_1 + 32'sd1) begin
          Delay6_reg[Delay6_t_0_1] <= Delay6_reg_next[Delay6_t_0_1];
        end
      end
    end

  always @* begin
    Delay6_out1 = Delay6_reg[3];
    Delay6_reg_next[0] = exp2;

    for(Delay6_t_0_0 = 32'sd0; Delay6_t_0_0 <= 32'sd2; Delay6_t_0_0 = Delay6_t_0_0 + 32'sd1) begin
      Delay6_reg_next[Delay6_t_0_0 + 32'sd1] = Delay6_reg[Delay6_t_0_0];
    end

  end

  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        for(Delay7_t_1 = 32'sd0; Delay7_t_1 <= 32'sd3; Delay7_t_1 = Delay7_t_1 + 32'sd1) begin
          Delay7_reg[Delay7_t_1] <= 9'sb000000000;
        end
      end
      else begin
        for(Delay7_t_0_1 = 32'sd0; Delay7_t_0_1 <= 32'sd3; Delay7_t_0_1 = Delay7_t_0_1 + 32'sd1) begin
          Delay7_reg[Delay7_t_0_1] <= Delay7_reg_next[Delay7_t_0_1];
        end
      end
    end

  always @* begin
    Delay7_out1 = Delay7_reg[3];
    Delay7_reg_next[0] = exp1;

    for(Delay7_t_0_0 = 32'sd0; Delay7_t_0_0 <= 32'sd2; Delay7_t_0_0 = Delay7_t_0_0 + 32'sd1) begin
      Delay7_reg_next[Delay7_t_0_0 + 32'sd1] = Delay7_reg[Delay7_t_0_0];
    end

  end

  assign Multiport_Switch_out1 = (Delay5_out1 == 1'b0 ? Delay6_out1 :
              Delay7_out1);

  always @(posedge clk or posedge reset)
    begin : Delay13_process
      if (reset == 1'b1) begin
        Delay13_reg <= {2{1'b0}};
      end
      else begin
        Delay13_reg[0] <= Delay4_out1;
        Delay13_reg[1] <= Delay13_reg[0];
      end
    end

  assign Delay13_out1 = Delay13_reg[1];

  assign Constant4_out1 = 1'b1;

  assign Bit_Concat1_out1 = {Constant4_out1, mant2};

  assign Data_Type_Conversion2_out1 = Bit_Concat1_out1;

  always @(posedge clk or posedge reset)
    begin : Delay12_process
      if (reset == 1'b1) begin
        for(Delay12_t_1 = 32'sd0; Delay12_t_1 <= 32'sd2; Delay12_t_1 = Delay12_t_1 + 32'sd1) begin
          Delay12_reg[Delay12_t_1] <= 9'b000000000;
        end
      end
      else begin
        for(Delay12_t_0_1 = 32'sd0; Delay12_t_0_1 <= 32'sd2; Delay12_t_0_1 = Delay12_t_0_1 + 32'sd1) begin
          Delay12_reg[Delay12_t_0_1] <= Delay12_reg_next[Delay12_t_0_1];
        end
      end
    end

  always @* begin
    Delay12_out1 = Delay12_reg[2];
    Delay12_reg_next[0] = Data_Type_Conversion2_out1;

    for(Delay12_t_0_0 = 32'sd0; Delay12_t_0_0 <= 32'sd1; Delay12_t_0_0 = Delay12_t_0_0 + 32'sd1) begin
      Delay12_reg_next[Delay12_t_0_0 + 32'sd1] = Delay12_reg[Delay12_t_0_0];
    end

  end

  assign Bit_Concat_out1 = {Constant4_out1, mant1};

  assign Data_Type_Conversion1_out1 = Bit_Concat_out1;

  always @(posedge clk or posedge reset)
    begin : Delay11_process
      if (reset == 1'b1) begin
        for(Delay11_t_1 = 32'sd0; Delay11_t_1 <= 32'sd2; Delay11_t_1 = Delay11_t_1 + 32'sd1) begin
          Delay11_reg[Delay11_t_1] <= 9'b000000000;
        end
      end
      else begin
        for(Delay11_t_0_1 = 32'sd0; Delay11_t_0_1 <= 32'sd2; Delay11_t_0_1 = Delay11_t_0_1 + 32'sd1) begin
          Delay11_reg[Delay11_t_0_1] <= Delay11_reg_next[Delay11_t_0_1];
        end
      end
    end

  always @* begin
    Delay11_out1 = Delay11_reg[2];
    Delay11_reg_next[0] = Data_Type_Conversion1_out1;

    for(Delay11_t_0_0 = 32'sd0; Delay11_t_0_0 <= 32'sd1; Delay11_t_0_0 = Delay11_t_0_0 + 32'sd1) begin
      Delay11_reg_next[Delay11_t_0_0 + 32'sd1] = Delay11_reg[Delay11_t_0_0];
    end

  end

  assign Multiport_Switch3_out1 = (Delay13_out1 == 1'b0 ? Delay12_out1 :
              Delay11_out1);

  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        Delay8_out1 <= 1'b0;
      end
      else begin
        Delay8_out1 <= Delay4_out1;
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        for(Delay9_t_1 = 32'sd0; Delay9_t_1 <= 32'sd1; Delay9_t_1 = Delay9_t_1 + 32'sd1) begin
          Delay9_reg[Delay9_t_1] <= 9'b000000000;
        end
      end
      else begin
        for(Delay9_t_0_0 = 32'sd0; Delay9_t_0_0 <= 32'sd1; Delay9_t_0_0 = Delay9_t_0_0 + 32'sd1) begin
          Delay9_reg[Delay9_t_0_0] <= Delay9_reg_next[Delay9_t_0_0];
        end
      end
    end

  assign Delay9_out1 = Delay9_reg[1];
  assign Delay9_reg_next[0] = Data_Type_Conversion1_out1;
  assign Delay9_reg_next[1] = Delay9_reg[0];

  always @(posedge clk or posedge reset)
    begin : Delay10_process
      if (reset == 1'b1) begin
        for(Delay10_t_1 = 32'sd0; Delay10_t_1 <= 32'sd1; Delay10_t_1 = Delay10_t_1 + 32'sd1) begin
          Delay10_reg[Delay10_t_1] <= 9'b000000000;
        end
      end
      else begin
        for(Delay10_t_0_0 = 32'sd0; Delay10_t_0_0 <= 32'sd1; Delay10_t_0_0 = Delay10_t_0_0 + 32'sd1) begin
          Delay10_reg[Delay10_t_0_0] <= Delay10_reg_next[Delay10_t_0_0];
        end
      end
    end

  assign Delay10_out1 = Delay10_reg[1];
  assign Delay10_reg_next[0] = Data_Type_Conversion2_out1;
  assign Delay10_reg_next[1] = Delay10_reg[0];

  assign Multiport_Switch2_out1 = (Delay8_out1 == 1'b0 ? Delay9_out1 :
              Delay10_out1);

  assign Add1_1 = {exp1[8], exp1};
  assign Add1_2 = {exp2[8], exp2};
  assign Add1_out1 = Add1_1 - Add1_2;

  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_out1 <= 10'sb0000000000;
      end
      else begin
        Delay_out1 <= Add1_out1;
      end
    end

  assign Abs_1 = {Delay_out1[9], Delay_out1};
  assign Abs_y = (Delay_out1 < 10'sb0000000000 ?  - (Abs_1) :
              {Delay_out1[9], Delay_out1});
  assign Abs_out1 = ((Abs_y[10] == 1'b0) && (Abs_y[9:4] != 6'b000000) ? 4'b1111 :
              (Abs_y[10] == 1'b1 ? 4'b0000 :
              Abs_y[3:0]));

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 4'b0000;
      end
      else begin
        Delay1_out1 <= Abs_out1;
      end
    end

  assign shift_arithmetic_cast = {4'b0, Delay1_out1};
  assign Shift_Arithmetic_out1 = Multiport_Switch2_out1 >>> shift_arithmetic_cast;

  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 9'b000000000;
      end
      else begin
        Delay2_out1 <= Shift_Arithmetic_out1;
      end
    end

  assign Add2_add_cast = {1'b0, Multiport_Switch3_out1};
  assign Add2_add_cast_1 = {1'b0, Delay2_out1};
  assign Add2_out1 = Add2_add_cast + Add2_add_cast_1;

  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 10'b0000000000;
      end
      else begin
        Delay3_out1 <= Add2_out1;
      end
    end

  assign Extract_Bits_out1 = Delay3_out1[9];

  assign Add_1 = {Multiport_Switch_out1[8], Multiport_Switch_out1};
  assign Add_2 = {9'b0, Extract_Bits_out1};
  assign Add_out1 = Add_1 + Add_2;

  assign exp_out = Add_out1;

  assign Extract_Bits1_out1 = Delay3_out1[8:0];

  assign Bit_Shift_out1 = Extract_Bits1_out1 >> 8'd1;

  assign Multiport_Switch4_out1 = (Extract_Bits_out1 == 1'b0 ? Extract_Bits1_out1 :
              Bit_Shift_out1);

  assign Extract_Bits2_out1 = Multiport_Switch4_out1[7:0];

  assign Data_Type_Conversion_out1 = Extract_Bits2_out1;

  assign mant_out = Data_Type_Conversion_out1;

endmodule  // stage2_add1

